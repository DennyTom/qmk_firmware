$include("minunit.h")

$py(engine_path = "../../../../users/dennytom/chording_engine/")

enum pseudolayers {
    ALWAYS_ON, QWERTY, NUM
};

// Macros to simplify chord definitions
$include(engine_path + "macros.inc")

// Keyboard states and settings
$py(custom_keymaps_array = False)
$include("keyboard.inc")

// The chord structure and chord functions (send key, switch pseudolayer, ...)
$include(engine_path + "chord.inc")

$KC("QWERTY", "H_TOP1", "KC_Q")
$KC("NUM", "H_TOP1", "KC_1")
$KC("QWERTY", "H_TOP2", "KC_W")
$KC("QWERTY", "H_TOP3", "KC_E")
$KC("QWERTY", "H_TOP1 + H_TOP2", "KC_ESC")
$KC("QWERTY", "H_BOT1 + H_BOT2", "KC_LSFT")
$OSK("QWERTY", "H_BOT2 + H_BOT3", "KC_LSFT")
$OSL("QWERTY", "H_BOT6 + H_BOT7", "NUM")
$MO("QWERTY", "H_BOT7 + H_BOT8", "NUM")
$DF("QWERTY", "H_BOT9 + H_BOT0", "NUM")
$AS("QWERTY", "H_BOT1", "KC_Z")
$LOCK("QWERTY", "H_TOP1 + H_TOP2 + H_BOT1 + H_BOT2")

// Register all chords, load chording logic
$include(engine_path + "chording_engine.inc")

// CLEAR_KB
$TEST("clear")
    for (int i = 0; i < $(NUM_OF_CHORDS); i++) {
        struct Chord* chord_ptr = (struct Chord*) pgm_read_word (&list_of_chords[i]);
        struct Chord chord_storage;
        memcpy_P(&chord_storage, chord_ptr, sizeof(struct Chord));
        struct Chord* chord = &chord_storage;
        
        *chord->state = READY;
        
        if (chord->counter) {
            *chord->counter = 1;
        }
    }
    
    history_index++;
    for (int j = 0; j < SAFE_RANGE-1; j++) {
        keyboard_history[history_index][j] = 1;
    }
    
    current_pseudolayer = 5;
    lock_next = true;
    autoshift_mode = false;
    command_mode = 1;
    in_leader_mode = true;
    dynamic_macro_mode = true;
    a_key_went_through = true;

    for (int i = 0; i < $(DYNAMIC_MACRO_MAX_LENGTH); i++) {
        dynamic_macro_buffer[i] = 1;
    }
    
    uint8_t clear_state = ACTIVATED;
    struct Chord clear_chord PROGMEM = {0, QWERTY, &clear_state, NULL, 0, 0, clear};
    clear_chord.function(&clear_chord);
    
    for (int i = 0; i < $(NUM_OF_CHORDS); i++) {
        struct Chord* chord_ptr = (struct Chord*) pgm_read_word (&list_of_chords[i]);
        struct Chord chord_storage;
        memcpy_P(&chord_storage, chord_ptr, sizeof(struct Chord));
        struct Chord* chord = &chord_storage;
        
        ASSERT_EQ(UINT, *chord->state, IDLE);
        
        if (chord->counter) {
            ASSERT_EQ(UINT, *chord->counter, 0);
        }
    }
    
    for (int j = 0; j < SAFE_RANGE-1; j++) {
        ASSERT_EQ(UINT, keyboard_history[history_index][j], 0);
    }
    
    ASSERT_EQ(UINT, current_pseudolayer, 1);
    ASSERT_EQ(UINT, lock_next, false);
    ASSERT_EQ(UINT, autoshift_mode, true);
    ASSERT_EQ(UINT, command_mode, 0);
    ASSERT_EQ(UINT, in_leader_mode, false);
    ASSERT_EQ(UINT, dynamic_macro_mode, false);
    ASSERT_EQ(UINT, a_key_went_through, false);

    for (int i = 0; i < $(DYNAMIC_MACRO_MAX_LENGTH); i++) {
        ASSERT_EQ(UINT, dynamic_macro_buffer[i], 0);
    }
$END_TEST()

$TEST("pause_ms")
    pause_ms(500);
    ASSERT_EQ(UINT, current_time, 500);
$END_TEST()

// KC
$TEST("single_dance_held_states")
    ASSERT_EQ(UINT, state_0, IDLE);
    process_record_user(TOP1, &pressed);
    pause_ms(CHORD_TIMEOUT);
    ASSERT_EQ(UINT, state_0, IDLE);
    pause_ms(1);
    ASSERT_EQ(UINT, state_0, ACTIVATED);
    pause_ms(DANCE_TIMEOUT);
    ASSERT_EQ(UINT, state_0, ACTIVATED);
    pause_ms(1);
    ASSERT_EQ(UINT, state_0, PRESS_FROM_ACTIVE);
    pause_ms(DANCE_TIMEOUT);
    ASSERT_EQ(UINT, state_0, PRESS_FROM_ACTIVE);
    pause_ms(1);
    ASSERT_EQ(UINT, state_0, FINISHED_FROM_ACTIVE);
    process_record_user(TOP1, &depressed);
    ASSERT_EQ(UINT, state_0, IDLE);
$END_TEST()

$TEST("single_dance_held_codes")
    ASSERT_EQ(UINT, keyboard_history[history_index][KC_Q], 0);
    process_record_user(TOP1, &pressed);
    pause_ms(CHORD_TIMEOUT);
    ASSERT_EQ(UINT, keyboard_history[history_index][KC_Q], 0);
    pause_ms(1);
    ASSERT_EQ(UINT, keyboard_history[history_index][KC_Q], 1);
    pause_ms(DANCE_TIMEOUT);
    ASSERT_EQ(UINT, keyboard_history[history_index][KC_Q], 1);
    pause_ms(1);
    ASSERT_EQ(UINT, keyboard_history[history_index][KC_Q], 1);
    pause_ms(DANCE_TIMEOUT);
    ASSERT_EQ(UINT, keyboard_history[history_index][KC_Q], 1);
    pause_ms(1);
    ASSERT_EQ(UINT, keyboard_history[history_index][KC_Q], 1);
    process_record_user(TOP1, &depressed);
    ASSERT_EQ(UINT, keyboard_history[history_index][KC_Q], 0);
$END_TEST()

$TEST("single_dance_tapped_states")
    ASSERT_EQ(UINT, state_0, IDLE);
    process_record_user(TOP1, &pressed);
    pause_ms(CHORD_TIMEOUT);
    ASSERT_EQ(UINT, state_0, IDLE);
    pause_ms(1);
    ASSERT_EQ(UINT, state_0, ACTIVATED);
    process_record_user(TOP1, &depressed);
    ASSERT_EQ(UINT, state_0, IDLE);
$END_TEST()

$TEST("single_dance_tapped_codes")
    ASSERT_EQ(UINT, keyboard_history[history_index][KC_Q], 0);
    process_record_user(TOP1, &pressed);
    pause_ms(CHORD_TIMEOUT);
    ASSERT_EQ(UINT, keyboard_history[history_index][KC_Q], 0);
    pause_ms(1);
    ASSERT_EQ(UINT, keyboard_history[history_index][KC_Q], 1);
    process_record_user(TOP1, &depressed);
    ASSERT_EQ(UINT, keyboard_history[history_index][KC_Q], 0);
$END_TEST()

// I can not actually track the states if the tap is faster than chord timeout

$TEST("single_dance_tapped_fast_codes")
    ASSERT_EQ(UINT, state_0, IDLE);
    process_record_user(TOP1, &pressed);
    pause_ms(1);
    process_record_user(TOP1, &depressed);
    ASSERT_EQ(UINT, keyboard_history[0][KC_Q], 0);
    ASSERT_EQ(UINT, keyboard_history[1][KC_Q], 1);
    ASSERT_EQ(UINT, keyboard_history[2][KC_Q], 0);
$END_TEST()

$TEST("subchords_are_ignored")
    ASSERT_EQ(UINT, state_0, IDLE);
    process_record_user(TOP1, &pressed);
    pause_ms(1);
    process_record_user(TOP2, &pressed);
    pause_ms(CHORD_TIMEOUT + 1);
    ASSERT_EQ(UINT, keyboard_history[history_index][KC_Q], 0);
    ASSERT_EQ(UINT, keyboard_history[history_index][KC_W], 0);
    ASSERT_EQ(UINT, keyboard_history[history_index][KC_ESC], 1);
$END_TEST()

$TEST("multiple_chords_at_once")
    ASSERT_EQ(UINT, state_0, IDLE);
    process_record_user(TOP1, &pressed);
    pause_ms(1);
    process_record_user(TOP3, &pressed);
    pause_ms(CHORD_TIMEOUT + 1);
    ASSERT_EQ(UINT, keyboard_history[history_index][KC_Q], 1);
    ASSERT_EQ(UINT, keyboard_history[history_index][KC_E], 1);
$END_TEST()

// MO
$TEST("momentary_layer")
    ASSERT_EQ(UINT, current_pseudolayer, QWERTY);
    process_record_user(BOT7, &pressed);
    pause_ms(1);
    process_record_user(BOT8, &pressed);
    pause_ms(CHORD_TIMEOUT + 1);
    ASSERT_EQ(UINT, current_pseudolayer, NUM);
    process_record_user(BOT7, &depressed);
    pause_ms(1);
    process_record_user(BOT8, &depressed);
    ASSERT_EQ(UINT, current_pseudolayer, QWERTY);
$END_TEST()

$TEST("momentary_layer_reset")
    ASSERT_EQ(UINT, current_pseudolayer, QWERTY);
    process_record_user(BOT7, &pressed);
    pause_ms(1);
    process_record_user(BOT8, &pressed);
    pause_ms(CHORD_TIMEOUT + 1);
    ASSERT_EQ(UINT, current_pseudolayer, NUM);
    pause_ms(DANCE_TIMEOUT + 1);
    ASSERT_EQ(UINT, current_pseudolayer, NUM);
    process_record_user(BOT7, &depressed);
    pause_ms(1);
    process_record_user(BOT8, &depressed);
    ASSERT_EQ(UINT, current_pseudolayer, QWERTY);
$END_TEST()

// DF
$TEST("permanent_layer")
    ASSERT_EQ(UINT, current_pseudolayer, QWERTY);
    process_record_user(BOT9, &pressed);
    pause_ms(1);
    process_record_user(BOT0, &pressed);
    pause_ms(CHORD_TIMEOUT + 1);
    ASSERT_EQ(UINT, current_pseudolayer, NUM);
    process_record_user(BOT9, &depressed);
    pause_ms(1);
    process_record_user(BOT0, &depressed);
    ASSERT_EQ(UINT, current_pseudolayer, NUM);
    pause_ms(1000);
    ASSERT_EQ(UINT, current_pseudolayer, NUM);
$END_TEST()

// AT
$TEST("autoshift_toggle")
    ASSERT_EQ(UINT, autoshift_mode, 1);
    uint8_t state = ACTIVATED;
    struct Chord chord PROGMEM = {0, QWERTY, &state, NULL, 0, 0, autoshift_toggle};
    chord.function(&chord);
    ASSERT_EQ(UINT, autoshift_mode, 0);
    state = ACTIVATED;
    chord.function(&chord);
    ASSERT_EQ(UINT, autoshift_mode, 1);
$END_TEST()

// AS
$TEST("autoshift_tap")
    process_record_user(BOT1, &pressed);
    pause_ms(CHORD_TIMEOUT + 1);
    process_record_user(BOT1, &depressed);
    
    ASSERT_EQ(UINT, keyboard_history[0][KC_Z], 0);
    ASSERT_EQ(UINT, keyboard_history[0][KC_LSFT], 0);
    
    ASSERT_EQ(UINT, keyboard_history[1][KC_Z], 1);
    ASSERT_EQ(UINT, keyboard_history[1][KC_LSFT], 0);
    
    ASSERT_EQ(UINT, keyboard_history[2][KC_Z], 0);
    ASSERT_EQ(UINT, keyboard_history[2][KC_LSFT], 0);
$END_TEST()

$TEST("autoshift_hold")
    $nonlocal(LONG_PRESS_MULTIPLIER)
    process_record_user(BOT1, &pressed);
    pause_ms(CHORD_TIMEOUT + 1);
    pause_ms($(LONG_PRESS_MULTIPLIER) * (DANCE_TIMEOUT + 1));
    process_record_user(BOT1, &depressed);
    
    ASSERT_EQ(UINT, keyboard_history[0][KC_Z], 0);
    ASSERT_EQ(UINT, keyboard_history[0][KC_LSFT], 0);
    
    ASSERT_EQ(UINT, keyboard_history[1][KC_Z], 0);
    ASSERT_EQ(UINT, keyboard_history[1][KC_LSFT], 1);
    
    ASSERT_EQ(UINT, keyboard_history[2][KC_Z], 1);
    ASSERT_EQ(UINT, keyboard_history[2][KC_LSFT], 1);
    
    ASSERT_EQ(UINT, keyboard_history[3][KC_Z], 0);
    ASSERT_EQ(UINT, keyboard_history[3][KC_LSFT], 1);
    
    ASSERT_EQ(UINT, keyboard_history[4][KC_Z], 0);
    ASSERT_EQ(UINT, keyboard_history[4][KC_LSFT], 0);
$END_TEST()

$TEST("autoshift_hold_off")
    autoshift_mode = 0;
    $nonlocal(LONG_PRESS_MULTIPLIER)
    process_record_user(BOT1, &pressed);
    pause_ms(CHORD_TIMEOUT + 1);
    pause_ms($(LONG_PRESS_MULTIPLIER) * (DANCE_TIMEOUT + 1));
    process_record_user(BOT1, &depressed);
    
    ASSERT_EQ(UINT, keyboard_history[0][KC_Z], 0);
    ASSERT_EQ(UINT, keyboard_history[0][KC_LSFT], 0);
    
    ASSERT_EQ(UINT, keyboard_history[1][KC_Z], 1);
    ASSERT_EQ(UINT, keyboard_history[1][KC_LSFT], 0);
    
    ASSERT_EQ(UINT, keyboard_history[2][KC_Z], 0);
    ASSERT_EQ(UINT, keyboard_history[2][KC_LSFT], 0);
$END_TEST()

// LOCK
$TEST("lock")
    ASSERT_EQ(UINT, keyboard_history[history_index][KC_LSFT], 0);
    process_record_user(BOT1, &pressed);
    process_record_user(BOT2, &pressed);
    pause_ms(CHORD_TIMEOUT + 1);
    ASSERT_EQ(UINT, keyboard_history[history_index][KC_LSFT], 1);
    process_record_user(BOT1, &depressed);
    ASSERT_EQ(UINT, keyboard_history[history_index][KC_LSFT], 0);
    pause_ms(1);
    process_record_user(BOT2, &depressed);
    pause_ms(1);
    process_record_user(TOP1, &pressed);
    process_record_user(TOP2, &pressed);
    process_record_user(BOT1, &pressed);
    process_record_user(BOT2, &pressed);
    pause_ms(CHORD_TIMEOUT + 1);
    process_record_user(TOP1, &depressed);
    pause_ms(1);
    process_record_user(TOP2, &depressed);
    process_record_user(BOT1, &depressed);
    process_record_user(BOT2, &depressed);
    pause_ms(1);
    process_record_user(BOT1, &pressed);
    process_record_user(BOT2, &pressed);
    pause_ms(CHORD_TIMEOUT + 1);
    ASSERT_EQ(UINT, keyboard_history[history_index][KC_LSFT], 1);
    process_record_user(BOT1, &depressed);
    ASSERT_EQ(UINT, keyboard_history[history_index][KC_LSFT], 1);
    pause_ms(1);
    process_record_user(BOT2, &depressed);
    pause_ms(1000);
    process_record_user(BOT1, &pressed);
    process_record_user(BOT2, &pressed);
    pause_ms(CHORD_TIMEOUT + 1);
    ASSERT_EQ(UINT, keyboard_history[history_index][KC_LSFT], 0);
    process_record_user(BOT1, &depressed);
    pause_ms(1);
    process_record_user(BOT2, &depressed);
    pause_ms(1000);
    ASSERT_EQ(UINT, keyboard_history[history_index][KC_LSFT], 0);
$END_TEST()

// OSK
$TEST("one_shot_key_tap")
    ASSERT_EQ(UINT, keyboard_history[history_index][KC_LSFT], 0);
    process_record_user(BOT2, &pressed);
    process_record_user(BOT3, &pressed);
    pause_ms(CHORD_TIMEOUT + 1);
    ASSERT_EQ(UINT, keyboard_history[history_index][KC_LSFT], 0);
    process_record_user(BOT2, &depressed);
    pause_ms(1);
    process_record_user(BOT3, &depressed);
    ASSERT_EQ(UINT, keyboard_history[history_index][KC_LSFT], 1);
    pause_ms(1000);
    ASSERT_EQ(UINT, keyboard_history[history_index][KC_LSFT], 1);
    
    process_record_user(TOP1, &pressed);
    pause_ms(CHORD_TIMEOUT + 1);
    process_record_user(TOP1, &depressed);
    ASSERT_EQ(UINT, keyboard_history[history_index][KC_LSFT], 0);
$END_TEST()

$TEST("one_shot_key_hold")
    ASSERT_EQ(UINT, keyboard_history[history_index][KC_LSFT], 0);
    process_record_user(BOT2, &pressed);
    process_record_user(BOT3, &pressed);
    pause_ms(CHORD_TIMEOUT + 1);
    pause_ms(DANCE_TIMEOUT + 1);
    ASSERT_EQ(UINT, keyboard_history[history_index][KC_LSFT], 1);
    
    process_record_user(TOP1, &pressed);
    pause_ms(CHORD_TIMEOUT + 1);
    process_record_user(TOP1, &depressed);
    ASSERT_EQ(UINT, keyboard_history[history_index][KC_LSFT], 1);
    
    process_record_user(BOT2, &depressed);
    ASSERT_EQ(UINT, keyboard_history[history_index][KC_LSFT], 0);
$END_TEST()

$TEST("one_shot_key_retrotapping")
    ASSERT_EQ(UINT, keyboard_history[history_index][KC_LSFT], 0);
    process_record_user(BOT2, &pressed);
    process_record_user(BOT3, &pressed);
    pause_ms(CHORD_TIMEOUT + 1);
    pause_ms(DANCE_TIMEOUT + 1);
    ASSERT_EQ(UINT, keyboard_history[history_index][KC_LSFT], 1);
    
    pause_ms(1000);
    
    process_record_user(BOT2, &depressed);
    ASSERT_EQ(UINT, keyboard_history[history_index][KC_LSFT], 1);
$END_TEST()

// OSL
$TEST("one_shot_layer_tap")
    ASSERT_EQ(UINT, current_pseudolayer, QWERTY);
    process_record_user(BOT6, &pressed);
    process_record_user(BOT7, &pressed);
    pause_ms(CHORD_TIMEOUT + 1);
    ASSERT_EQ(UINT, current_pseudolayer, QWERTY);
    process_record_user(BOT6, &depressed);
    pause_ms(1);
    process_record_user(BOT7, &depressed);
    ASSERT_EQ(UINT, current_pseudolayer, NUM);
    pause_ms(1000);
    ASSERT_EQ(UINT, current_pseudolayer, NUM);
    
    process_record_user(TOP1, &pressed);
    pause_ms(CHORD_TIMEOUT + 1);
    process_record_user(TOP1, &depressed);
    ASSERT_EQ(UINT, current_pseudolayer, QWERTY);
$END_TEST()

$TEST("one_shot_layer_hold")
    ASSERT_EQ(UINT, current_pseudolayer, QWERTY);
    process_record_user(BOT6, &pressed);
    process_record_user(BOT7, &pressed);
    pause_ms(CHORD_TIMEOUT + 1);
    pause_ms(DANCE_TIMEOUT + 1);
    ASSERT_EQ(UINT, current_pseudolayer, NUM);
    
    process_record_user(TOP1, &pressed);
    pause_ms(CHORD_TIMEOUT + 1);
    process_record_user(TOP1, &depressed);
    ASSERT_EQ(UINT, current_pseudolayer, NUM);
    
    process_record_user(BOT6, &depressed);
    ASSERT_EQ(UINT, current_pseudolayer, QWERTY);
$END_TEST()

$TEST("one_shot_layer_retrotapping")
    ASSERT_EQ(UINT, current_pseudolayer, QWERTY);
    process_record_user(BOT6, &pressed);
    process_record_user(BOT7, &pressed);
    pause_ms(CHORD_TIMEOUT + 1);
    pause_ms(DANCE_TIMEOUT + 1);
    ASSERT_EQ(UINT, current_pseudolayer, NUM);
    
    pause_ms(1000);
    
    process_record_user(BOT6, &depressed);
    ASSERT_EQ(UINT, current_pseudolayer, NUM);
$END_TEST()

// TODO:
// KL
// KM
// KK
// CMD
// LEADER
// DYNAMIC MACRO

// These two are leaving the chording engine, they kinda have to be tested manually
// TO
// RESET

$runner()